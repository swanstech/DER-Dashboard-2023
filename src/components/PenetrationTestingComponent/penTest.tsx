import React, { useState, useEffect } from 'react';

interface DeviceData {
  der_name?: string;
  der_type?: string;
  location?: string;
}

interface HardwareData {
  [key: string]: [
    string, string, string, string, string, string, string, string, string, string,
    string, string, string, string, string, string, string, string, string, string,
    string, string, string, string, string, string, string, string, string, string,
    string, string
  ][];
}

interface TestFormData {
  creationDate?: string;
  testScope?: string;
  reason?: string;
}
const styles = {
  detailsTable: {
    width: '100%',
    borderCollapse: 'collapse',
    marginTop: '20px',
  },

  detailsTableHeader: {
    backgroundColor: '#3498db',
    color: 'white',
  },

  detailsTableHeaderCell: {
    padding: '10px',
    border: '1px solid #3498db',
    textAlign: 'left',
  },

  detailsTableRow: {
    border: '1px solid #3498db',
  },

  detailsTableCell: {
    padding: '10px',
    border: '1px solid #3498db',
    textAlign: 'left',
    fontSize: '12px',
  },
  container: {
    display: 'flex',
    flexDirection: 'column', // Adjusted to column layout
    alignItems: 'stretch', // Added to stretch containers
    padding: '30px', // Adjust padding as needed
    boxSizing: 'border-box',
    border: '1px solid #ddd',
    borderRadius: '20px',
    boxShadow: '0 0 20px rgba(0, 0, 0, 0.2)',
  },

  leftContainer: {
    flex: '1',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center', // Center vertically
    alignItems: 'center',
    textAlign: 'center',
    // Center horizontally
    marginBottom: '20px', // Added margin to separate from the right container
  },
  rightContainer: {
    flex: '1',
    paddingLeft: '20px', // Adjust as needed
  },

  form: {
    marginTop: '30px',
    width: '100%',
    textAlign: 'center',
    alignItems: 'center',
  },
  label: {
    display: 'block',
    marginBottom: '10px',
    fontSize: '16px',
    fontWeight: 'bold',
    textAlign: 'center',
  },
  labelT: {
    display: 'block',
    marginBottom: '10px',
    fontSize: '16px',
    textAlign: 'center',
  },
  input: {
    width: '30%', // Adjust the percentage as needed
    padding: '12px',
    marginBottom: '20px',
    border: '2px solid #ccc',
    borderRadius: '3px',
    boxSizing: 'border-box',
    fontSize: '12px',
  },
  button: {
    padding: '15px',
    background: '#4CAF50',
    color: 'white',
    border: 'none',
    borderRadius: '6px',
    cursor: 'pointer',
    fontSize: '18px',
  },

  viewResultsButton: {
    padding: '15px',
    background: '#3498db',
    color: 'white',
    border: 'none',
    borderRadius: '6px',
    cursor: 'pointer',
    fontSize: '18px',
    marginTop: '20px',
    marginLeft: 'auto',
  },
  tableContainer: {
    border: '1px solid #3498db',
    borderRadius: '10px',
    marginTop: '20px',
    overflow: 'auto',
  },

  loadingSpinner: {
    border: '4px solid rgba(0, 0, 0, 0.1)',
    borderTop: '4px solid #3498db',
    borderRadius: '55%',
    width: '30px',
    height: '30px',
    animation: typeof document !== 'undefined' ? 'spin 1s linear infinite' : 'none',
    display: 'inline-block',
    marginLeft: '30px',
    marginTop: '30px',
  },

  priorityHigh: {
    backgroundColor: 'red',
    color: 'white',
    padding: '5px',
    borderRadius: '5px',
  },

  priorityMedium: {
    backgroundColor: 'orange',
    color: 'white',
    padding: '5px',
    borderRadius: '5px',
  },

  priorityLow: {
    backgroundColor: 'yellow',
    color: 'black',
    padding: '5px',
    borderRadius: '5px',
  },

  arrow: {
    cursor: 'pointer',
    textDecoration: 'underline',
    color: 'blue',
  },
  pagination: {
    display: 'flex',
    justifyContent: 'center',
    marginTop: '20px',
  },

  pageButton: {
    padding: '8px 12px',
    margin: '0 4px',
    cursor: 'pointer',
    color: 'white',
    border: '1px solid #3498db',
    backgroundColor: '#3498db',
    borderRadius: '4px',
  },

  pageButtonHover: {
    backgroundColor: '#2980b9',
  },
};
const riskLevelStyles = {
  riskCritical: {
    backgroundColor: 'red',
    color: 'white',
    padding: '5px',
    borderRadius: '5px',
  },

  riskHigh: {
    backgroundColor: 'orange',
    color: 'white',
    padding: '5px',
    borderRadius: '5px',
  },

  riskMedium: {
    backgroundColor: 'yellow',
    color: 'black',
    padding: '5px',
    borderRadius: '5px',
  },

  riskLow: {
    backgroundColor: 'green',
    color: 'white',
    padding: '5px',
    borderRadius: '5px',
  },
};

const PAGE_SIZE = 10;

const TestResultsTable = ({ testResults }) => {

  const getRiskLevelIcon = (riskLevel) => {
    // Replace with the appropriate icon for each risk level
    switch (riskLevel) {
      case 'Critical':
        return 'ðŸ”´'; // Replace with your critical icon
      case 'High':
        return 'ðŸŸ '; // Replace with your high icon
      case 'Medium':
        return 'ðŸŸ¡'; // Replace with your medium icon
      case 'Low':
        return 'ðŸŸ¢'; // Replace with your low icon
      default:
        return '';
    }
  };
  
  // Function to get priority icon
  const getPriorityIcon = (priority) => {
    // Replace with the appropriate icon for each priority level
    switch (priority) {
      case 'High':
        return 'ðŸ”¥'; // Replace with your high priority icon
      case 'Medium':
        return 'âš ï¸'; // Replace with your medium priority icon
      case 'Low':
        return 'ðŸŸ¢'; // Replace with your low priority icon
      default:
        return '';
    }
  }
  const [currentPage, setCurrentPage] = useState(1);
  const [expandedColumns, setExpandedColumns] = useState([]);

  const totalPages = Math.ceil(testResults.length / PAGE_SIZE);

  const startIndex = (currentPage - 1) * PAGE_SIZE;
  const endIndex = startIndex + PAGE_SIZE;
  const currentResults = testResults.slice(startIndex, endIndex);

  const handlePageChange = (newPage) => {
    setCurrentPage(newPage);
    setExpandedColumns([]); // Collapse all columns when changing the page
  };

  const toggleColumnExpansion = (columnIndex) => {
    setExpandedColumns((prevExpandedColumns) => {
      const isColumnExpanded = prevExpandedColumns.includes(columnIndex);
      if (isColumnExpanded) {
        // If the column is already expanded, collapse it
        return prevExpandedColumns.filter((colIndex) => colIndex !== columnIndex);
      } else {
        // If the column is not expanded, expand it
        return [...prevExpandedColumns, columnIndex];
      }
    });
  };

  const truncateText = (text, maxLength) => {
    return text.length > maxLength ? text.slice(0, maxLength) + '...' : text;
  };

  return (
    <div>
      <div style={styles.tableContainer}>
        <table style={styles.detailsTable as any}>
          <thead>
            <tr style={styles.detailsTableHeader}>
              {Object.keys(currentResults[0]).map((header, index) => (
                <th key={index} style={styles.detailsTableHeaderCell as any}>
                  {header}
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {currentResults.map((result, rowIndex) => (
              <tr key={rowIndex} style={styles.detailsTableRow}>
                {Object.entries(result).map(([key, value], colIndex) => (
                  <td
                    key={colIndex}
                    style={{
                      ...styles.detailsTableCell as any,
                      overflow: expandedColumns.includes(colIndex) ? 'visible' : 'hidden',
                    }}
                  >
                    {key === 'RiskLevel' && (
                      <span style={
                        value === 'Critical'
                          ? riskLevelStyles.riskCritical
                          : (value === 'High'
                            ? riskLevelStyles.riskHigh
                            : (value === 'Medium'
                              ? riskLevelStyles.riskMedium
                              : riskLevelStyles.riskLow))
                      }>
                         {getRiskLevelIcon(value)} <span style={{ marginLeft: '5px' }}>{String(value)}</span>
                      </span>
                    )}
                    {key === 'Priority' && (
                      <span style={value === 'High' ? styles.priorityHigh : (value === 'Medium' ? styles.priorityMedium : styles.priorityLow)}>
                         {getPriorityIcon(value)} <span style={{ marginLeft: '5px' }}>{String(value)}</span>
                      </span>
                    )}
                    {key !== 'Priority' && key !== 'RiskLevel' && (
                      <div>
                        {String(value).length > 20 ? (
                          <>
                            {expandedColumns.includes(colIndex) ? value : truncateText(value, 20)}
                            <span style={styles.arrow} onClick={() => toggleColumnExpansion(colIndex)}>
                              &nbsp;{expandedColumns.includes(colIndex) ? 'â†‘' : 'â†“'}
                            </span>
                          </>
                        ) : String(value)}
                      </div>
                    )}
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
      <div style={styles.pagination}>
        {Array.from({ length: totalPages }, (_, index) => index + 1).map((page) => (
          <span
            key={page}
            style={{
              ...styles.pageButton,
              backgroundColor: page === currentPage ? '#2980b9' : '#3498db',
            }}
            onClick={() => handlePageChange(page)}
          >
            {page}
          </span>
        ))}
      </div>
    </div>
  );
};

export default function PenTest({ derId }) {
  const [hardwareData, setHardwareData] = useState<HardwareData | null>(null);
  const [deviceData, setDeviceData] = useState<DeviceData>({});
  const [testFormData, setTestFormData] = useState<TestFormData>({});
  const [loading, setLoading] = useState(false);
  const [testResultsAvailable, setTestResultsAvailable] = useState(false); // New state variable
  const [loadingSpinnerVisible, setLoadingSpinnerVisible] = useState(false);
  const deviceId = derId || "DER_1";
  const [viewResultsButtonDisabled, setViewResultsButtonDisabled] = useState(false);

  // Placeholder for actual device ID
  const [testResults, setTestResults] = useState([]); // New state variable for test results

  const handleViewResults = async () => {

    setViewResultsButtonDisabled(true);
    try {
      const response = await fetch('/api/testResults'); // Replace with your actual API endpoint

      if (!response.ok) {
        console.error("HTTP error", response.status);
        // If there's an error, provide dummy data
        setTestResults([
          {
            Priority: 'High',
            Vulnerability: 'SQL Injection',
            Status: 'Open',
            Discovered: '2023-01-01',
            DiscoveredBy: 'Security Team',
            Resolution: 'Patch applied sfjdfbb khfkdhfk kdhkfhek lsjdlkjfdl lefhlekfhl lhdlkfhle lhflkehflehFL',
            RiskLevel: 'High',
            Tags: '',
          },
          // Add more test results as needed
        ]);
        return;
      }

      const testResultsData = await response.json();
      setTestResults(testResultsData);
    } catch (error) {
      console.error("Error fetching test results:", error);
      // If there's an error, provide dummy data
      setTestResults([
        {
          Priority: 'High',
          Vulnerability: 'SQL Injection',
          Status: 'Open',
          Discovered: '2023-01-01',
          DiscoveredBy: 'Security Scanner',
          Resolution: 'Patch applied',
          RiskLevel: 'High',
          Tags: '',
        },
        // Add more test results as needed
      ]);
    }
  };


  useEffect(() => {
    async function fetchData() {
      try {
        const response = await fetch('/api/deviceInfo');

        if (!response.ok) {
          console.error("HTTP error", response.status);
          return;
        }

        const rawData = await response.json();

        if (typeof rawData.body === 'string') {
          const parsedData = JSON.parse(rawData.body);
          setHardwareData(parsedData);
        } else {
          setHardwareData(rawData);
        }
      } catch (error) {
        console.error("Error fetching data:", error);
      }
    }

    fetchData();
  }, []);

  useEffect(() => {
    if (typeof document !== 'undefined') {
      const keyframes = `@keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }`;

      // Apply the keyframes to the head of the document
      const styleSheet = document.styleSheets[0];
      styleSheet.insertRule(keyframes, styleSheet.cssRules.length);
    }
  }, []);

  useEffect(() => {
    if (hardwareData && hardwareData.data) {
      const filteredData = hardwareData.data.find(item => {
        const [derId] = Object.values(item);
        return derId[0] === deviceId;
      });

      if (filteredData) {
        const [
          der_id, der_name, der_type, manufacturer_id, manufacturer_serial_number,
          manufacture_date, manufacturer_hw_version, manufacturer_info,
          manufacturer_model_number, latest_sw_version, latest_sw_release_date,
          latest_firmware_version, latest_firmware_release_date, location, setting_id,
          der_id_set, set_max_ac_current, set_max_usable_energy_storage,
          set_minpf_overexcited_limit, set_minpf_underexcited_limit, set_max_apparent_power,
          set_max_reactive_power_tx, set_max_reactive_power_rx, set_max_active_power_tx,
          set_max_energy_storage, set_min_ac_voltage, set_max_ac_voltage,
          current_sw_version, sw_last_update_date, current_firmware_version,
          firmware_last_update_date
        ] = filteredData[Object.keys(filteredData)[0]];

        setDeviceData({
          der_name: der_name,
          der_type: der_type,
          location: location,
        });
      }
    }
  }, [hardwareData, deviceId]);




  const handleInputChange = (e) => {
    setTestFormData({
      ...testFormData,
      [e.target.name]: e.target.value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      // Set loading to true when starting the API call
      setLoading(true);
      setLoadingSpinnerVisible(true);

      // Add your API endpoint for saving the test data
      const response = await fetch('/api/saveTestData', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          derId: deviceId,
          der_name: deviceData.der_name,
          der_type: deviceData.der_type,
          location: deviceData.location,
          creationDate: testFormData.creationDate,
          testScope: testFormData.testScope,
          reason: testFormData.reason,
        }),
      });

      if (!response.ok) {
        console.error("HTTP error", response.status);
        setTimeout(() => {
          setLoading(false);
          setTestResultsAvailable(true);
          setLoadingSpinnerVisible(false);
        }, 10000);
        // Handle error, show message, etc.
        return;
      }

      // Successful API call
      console.log("Test data saved successfully!");

      // Set a timeout for 30 seconds to change loading state and display the button
      setTimeout(() => {
        setLoading(false);
        setTestResultsAvailable(true);
        setLoadingSpinnerVisible(false);
      }, 10000); // 30 seconds delay
    } catch (error) {
      console.error("Error saving test data:", error);
      // Handle error, show message, etc.
    }
  };

  return (
    <><div style={styles.container as any}>
      <div style={styles.leftContainer as any}>
        {deviceData.der_name ? (
          <>
            <p style={styles.labelT as any}><strong>DER Name:</strong> {deviceData.der_name}</p>
            <p style={styles.labelT as any}><strong>Type:</strong> {deviceData.der_type}</p>
            <p style={styles.labelT as any}><strong>Location:</strong> {deviceData.location}</p>

            <form style={styles.form as any} onSubmit={handleSubmit}>
              <div style={{ textAlign: 'center' }}>
                <label style={styles.label as any} htmlFor="creationDate">Test Creation Date:</label>
                <input
                  style={styles.input as any}
                  type="date"
                  id="creationDate"
                  name="creationDate"
                  value={testFormData.creationDate || ''}
                  onChange={handleInputChange} />
              </div>

              <div style={{ textAlign: 'center' }}>
                <label style={styles.label as any} htmlFor="testScope">Test Scope:</label>
                <select
                  style={styles.input as any} // Cast to 'any'
                  id="testScope"
                  name="testScope"
                  value={testFormData.testScope || ''}
                  onChange={handleInputChange}
                >
                  <option value="">Select Test Scope</option>
                  <option value="Website penetration testing">Website penetration testing</option>
                  <option value="API penetration testing">API penetration testing</option>
                  <option value="Network penetration testing">Network penetration testing</option>
                  <option value="Wireless penetration testing">Wireless penetration testing</option>
                  <option value="Authorisation penetration testing">Authorisation penetration testing</option>
                </select>
              </div>

              <div style={{ textAlign: 'center' }}>
                <label style={styles.label as any} htmlFor="reason">Reason:</label>
                <select
                  style={styles.input as any} // Cast to 'any'
                  id="reason"
                  name="reason"
                  value={testFormData.reason || ''}
                  onChange={handleInputChange}
                >
                  <option value="">Select Reason</option>
                  <option value="Security Standard Compliance">Security Standard Compliance</option>
                  <option value="Periodic test">Periodic test</option>
                  <option value="Risk Ranking">Risk Ranking</option>
                  <option value="Recent Security Incident">Recent Security Incident</option>
                  <option value="New enhancement and patchment">New enhancement and patchment</option>
                </select>
              </div>

              <button type="submit" style={styles.button}>Submit </button>{loading && loadingSpinnerVisible && (
                <div style={styles.loadingSpinner}></div>
              )} {!loading && testResultsAvailable && (
                <button style={styles.viewResultsButton} onClick={() => handleViewResults()} disabled={viewResultsButtonDisabled}>
                  View Test Results
                </button>
              )}


            </form>



          </>
        ) : (
          <>
            <p>No data available for the specified device ID.</p>
            <form style={styles.form as any} onSubmit={handleSubmit}>
              <div style={{ textAlign: 'center' }}>
                <label style={styles.label as any} htmlFor="creationDate">Test Creation Date:</label>
                <input
                  style={styles.input as any}
                  type="date"
                  id="creationDate"
                  name="creationDate"
                  value={testFormData.creationDate || ''}
                  onChange={handleInputChange} />
              </div>

              <div style={{ textAlign: 'center' }}>
                <label style={styles.label as any} htmlFor="testScope">Test Scope:</label>
                <select
                  style={styles.input as any} // Cast to 'any'
                  id="testScope"
                  name="testScope"
                  value={testFormData.testScope || ''}
                  onChange={handleInputChange}
                >
                  <option value="">Select Test Scope</option>
                  <option value="Website penetration testing">Website penetration testing</option>
                  <option value="API penetration testing">API penetration testing</option>
                  <option value="Network penetration testing">Network penetration testing</option>
                  <option value="Wireless penetration testing">Wireless penetration testing</option>
                  <option value="Authorisation penetration testing">Authorisation penetration testing</option>
                </select>
              </div>

              <div style={{ textAlign: 'center' }}>
                <label style={styles.label as any} htmlFor="reason">Reason:</label>
                <select
                  style={styles.input as any} // Cast to 'any'
                  id="reason"
                  name="reason"
                  value={testFormData.reason || ''}
                  onChange={handleInputChange}
                >
                  <option value="">Select Reason</option>
                  <option value="Security Standard Compliance">Security Standard Compliance</option>
                  <option value="Periodic test">Periodic test</option>
                  <option value="Risk Ranking">Risk Ranking</option>
                  <option value="Recent Security Incident">Recent Security Incident</option>
                  <option value="New enhancement and patchment">New enhancement and patchment</option>
                </select>
              </div>

              <button type="submit" style={styles.button}>Submit</button> {loading && loadingSpinnerVisible && (
                <div style={styles.loadingSpinner}></div>
              )}{!loading && testResultsAvailable && (
                <button style={styles.viewResultsButton} onClick={() => handleViewResults()} disabled={viewResultsButtonDisabled}>
                  View Test Results
                </button>
              )}


            </form>


          </>
        )}
      </div>
      <div style={styles.rightContainer as any}>
        {/* ... (form content) */}
        {testResults.length > 0 && (
          <TestResultsTable testResults={testResults} />
        )}
      </div>
    </div></>
  );

  
}
