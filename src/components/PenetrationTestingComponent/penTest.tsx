import React, { useState, useEffect } from 'react';

interface DeviceData {
  der_name?: string;
  der_type?: string;
  location?: string;
}

interface HardwareData {
  [key: string]: [
    string, string, string, string, string, string, string, string, string, string,
    string, string, string, string, string, string, string, string, string, string,
    string, string, string, string, string, string, string, string, string, string,
    string, string
  ][];
}

interface TestFormData {
  creationDate?: string;
  testScope?: string;
  reason?: string;
}
const styles = {
  buttonContainer: {
    display: 'flex',
    alignItems: 'center',
    
    marginRight: '465px' // Adjust as needed
  },
  detailsTable: {
    width: '100%',
    borderCollapse: 'collapse',
    marginTop: '20px',
  },

  detailsTableHeader: {
    backgroundColor: '#3498db',
    color: 'white',
  },

  detailsTableHeaderCell: {
    padding: '10px',
    border: '1px solid #3498db',
    textAlign: 'left',
  },

  detailsTableRow: {
    border: '1px solid #3498db',
  },

  detailsTableCell: {
    padding: '12px',
    border: '1px solid #3498db',
    textAlign: 'left',
    fontSize: '12px',
  },
  container: {
    display: 'flex',
    flexDirection: 'column', // Adjusted to column layout
    alignItems: 'stretch', // Added to stretch containers
    padding: '30px', // Adjust padding as needed
    boxSizing: 'border-box',
    border: '1px solid #ddd',
    borderRadius: '20px',
    boxShadow: '0 0 20px rgba(0, 0, 0, 0.2)',
  },

  leftContainer: {
    flex: '1',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center', // Center vertically
    alignItems: 'center',
    textAlign: 'center',
    // Center horizontally
    marginBottom: '20px', // Added margin to separate from the right container
  },
  rightContainer: {
    flex: '1',
    paddingLeft: '20px', // Adjust as needed
  },

  form: {
    marginTop: '20px',
    width: '100%',
    textAlign: 'center',
    alignItems: 'left',
    marginRight :'20px'
  },
  formLeft: {
    marginTop: '20px',
    width: '150px',
    marginLeft:'200px',
    textAlign: 'center',
    alignItems: 'center',
    height:'150px'
  },
  label: {
    display: 'block',
    marginBottom: '10px',
    fontSize: '16px',
    fontWeight: 'bold',
    textAlign: 'center',
  },
  labelT: {
    display: 'block',
    marginBottom: '10px',
    fontSize: '16px',
    textAlign: 'center',
  },
  input: {
    width: '30%', // Adjust the percentage as needed
    padding: '12px',
    marginBottom: '20px',
    border: '2px solid #ccc',
    borderRadius: '3px',
    boxSizing: 'border-box',
    fontSize: '12px',
  },
  button: {
    padding: '12px',
    background: '#4CAF50',
    color: 'white',
    border: 'none',
    borderRadius: '6px',
    cursor: 'pointer',
    fontSize: '18px',
    width:'100px',
    marginLeft : '60px'


  },

  viewResultsButton: {
    padding: '5px',
    width:'100px',
    background: '#3498db',
    color: 'white',
    border: 'none',
    borderRadius: '6px',
    cursor: 'pointer',
    fontSize: '16px',
    marginLeft: '10px',
  },
  tableContainer: {
    border: '1px solid #3498db',
    borderRadius: '10px',
    marginTop: '20px',
    overflow: 'auto',
  },

  loadingSpinner: {
    border: '4px solid rgba(0, 0, 0, 0.1)',
    borderTop: '4px solid #3498db',
    borderRadius: '55%',
    width: '30px',
    height: '30px',
    animation: typeof document !== 'undefined' ? 'spin 1s linear infinite' : 'none',
    display: 'inline-block',
    marginLeft: '30px',
    marginTop: '30px',
  },

  priorityHigh: {
    backgroundColor: 'red',
    color: 'white',
    padding: '3px',
    borderRadius: '5px',
  },

  priorityMedium: {
    backgroundColor: 'orange',
    color: 'white',
    padding: '3px',
    borderRadius: '5px',
  },

  priorityLow: {
    backgroundColor: 'yellow',
    color: 'black',
    padding: '3px',
    borderRadius: '5px',
  },

  arrow: {
    cursor: 'pointer',
    textDecoration: 'underline',
    color: 'blue',
  },
  pagination: {
    display: 'flex',
    justifyContent: 'center',
    marginTop: '20px',
  },

  pageButton: {
    padding: '8px 12px',
    margin: '0 4px',
    cursor: 'pointer',
    color: 'white',
    border: '1px solid #3498db',
    backgroundColor: '#3498db',
    borderRadius: '4px',
  },

  pageButtonHover: {
    backgroundColor: '#2980b9',
  },
};
const riskLevelStyles = {
  riskCritical: {
    backgroundColor: 'red',
    color: 'white',
    padding: '3px',
    borderRadius: '5px',
  },

  riskHigh: {
    backgroundColor: 'orange',
    color: 'white',
    padding: '3px',
    borderRadius: '5px',
  },

  riskMedium: {
    backgroundColor: 'yellow',
    color: 'black',
    padding: '3px',
    borderRadius: '5px',
  },

  riskLow: {
    backgroundColor: 'green',
    color: 'white',
    padding: '3px',
    borderRadius: '5px',
  },
};

const leftContainer = {
  flex: '1',
  display: 'flex',
  flexDirection: 'row',  // Change to row
  justifyContent: 'space-between',  // Adjust as needed
  alignItems: 'left',
  textAlign: 'center',
  // ...
};



const PAGE_SIZE = 5;

const TestResultsTable = ({ testResults }) => {

  const [currentPage, setCurrentPage] = useState(1);
  const [expandedColumns, setExpandedColumns] = useState([]);

  const totalPages = Math.ceil(testResults.length / PAGE_SIZE);

  const startIndex = (currentPage - 1) * PAGE_SIZE;
  const endIndex = startIndex + PAGE_SIZE;
  const currentResults = testResults.slice(startIndex, endIndex);

  const handlePageChange = (newPage) => {
    setCurrentPage(newPage);
    setExpandedColumns([]); // Collapse all columns when changing the page
  };

  const toggleColumnExpansion = (columnIndex) => {
    setExpandedColumns((prevExpandedColumns) => {
      const isColumnExpanded = prevExpandedColumns.includes(columnIndex);
      if (isColumnExpanded) {
        // If the column is already expanded, collapse it
        return prevExpandedColumns.filter((colIndex) => colIndex !== columnIndex);
      } else {
        // If the column is not expanded, expand it
        return [...prevExpandedColumns, columnIndex];
      }
    });
  };

  const truncateText = (text, maxLength) => {
    return text.length > maxLength ? text.slice(0, maxLength) + '...' : text;
  };

  return (
    <div>
      <div style={styles.tableContainer}>
        <table style={styles.detailsTable as any}>
          <thead>
            <tr style={styles.detailsTableHeader}>
              {Object.keys(currentResults[0]).map((header, index) => (
                <th key={index} style={styles.detailsTableHeaderCell as any}>
                  {header}
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {currentResults.map((result, rowIndex) => (
              <tr key={rowIndex} style={styles.detailsTableRow}>
                {Object.entries(result).map(([key, value], colIndex) => (
                  <td
                    key={colIndex}
                    style={{
                      ...styles.detailsTableCell as any,
                      overflow: expandedColumns.includes(colIndex) ? 'visible' : 'hidden',

                    }}
                  >
                    {key === 'Risk Level' && (
                      <><span style={value === 'Critical'
                        ? riskLevelStyles.riskCritical
                        : (value === 'High'
                          ? riskLevelStyles.riskHigh
                          : (value === 'Medium'
                            ? riskLevelStyles.riskMedium
                            : riskLevelStyles.riskLow))}>
                        <span style={{ marginLeft: '5px' }}>{String(value)}</span>
                      </span></>
                    )}
                    {key === 'Priority' && (
                      <><span style={value === 'High' ? styles.priorityHigh : (value === 'Medium' ? styles.priorityMedium : styles.priorityLow)}>
                        <span style={{ marginLeft: '5px' }}>{String(value)}</span>
                      </span></>
                    )}
                    {key !== 'Priority' && key !== 'Risk Level' && (
                      <div>
                        {String(value).length > 40 ? (
                          <>
                            {expandedColumns.includes(colIndex) ? value : truncateText(value, 20)}
                            <span style={styles.arrow} onClick={() => toggleColumnExpansion(colIndex)}>
                              &nbsp;{expandedColumns.includes(colIndex) ? '‚Üë' : '‚Üì'}
                            </span>
                          </>
                        ) : String(value)}
                      </div>
                    )}
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
      <div style={styles.pagination}>
        {Array.from({ length: totalPages }, (_, index) => index + 1).map((page) => (
          <span
            key={page}
            style={{
              ...styles.pageButton,
              backgroundColor: page === currentPage ? '#2980b9' : '#3498db',
            }}
            onClick={() => handlePageChange(page)}
          >
            {page}
          </span>
        ))}
      </div>
    </div>
  );
};

export default function PenTest({ derId }) {
  const [hardwareData, setHardwareData] = useState<HardwareData | null>(null);
  const [deviceData, setDeviceData] = useState<DeviceData>({});
  const [testFormData, setTestFormData] = useState<TestFormData>({});
  const [loading, setLoading] = useState(false);
  const [testResultsAvailable, setTestResultsAvailable] = useState(false); // New state variable
  const [loadingSpinnerVisible, setLoadingSpinnerVisible] = useState(false);
  const deviceId = derId || "DER_1";
  const [viewResultsButtonDisabled, setViewResultsButtonDisabled] = useState(false);

  // Placeholder for actual device ID
  const [testResults, setTestResults] = useState([]); // New state variable for test results

  const handleViewResults = async () => {

    setViewResultsButtonDisabled(true);
    try {
      const response = await fetch('/api/testResults'); // Replace with your actual API endpoint

      if (!response.ok) {
        console.error("HTTP error", response.status);

        // If there's an error, provide dummy data
        setTestResults([
          {
            "Vulnerability": "False Data Injection",
            "Risk Level": "Critical",
            "Status": "Open",
            "Discovered": "2/12/2023",
            "Discovered By": "Swans Team",
            "Resolution": "Secure communication protocols, encryption, and authentication mechanisms",
            "Priority": "High",
            "Tags": ["EVCS", "Charging Data", "Integrity"]
          },
          {
            "Vulnerability": "Man-in-the-Middle",
            "Risk Level": "High",
            "Status": "Closed",
            "Discovered": "1/12/2023",
            "Discovered By": "Unknown",
            "Resolution": "Robust encryption, authentication mechanisms, and secure communication protocols",
            "Priority": "Medium",
            "Tags": ["EVCS", "Data Transmission", "Integrity", "Confidentiality"]
          },
          {
            "Vulnerability": "Denial of Service",
            "Risk Level": "High",
            "Status": "Open",
            "Discovered": "3/12/2023",
            "Discovered By": "Unknown",
            "Resolution": "Traffic filtering, rate limiting, and anomaly detection techniques",
            "Priority": "High",
            "Tags": ["EVCS", "Network Functionality", "Reliability"]
          },
          {
            "Vulnerability": "Malware Injections",
            "Risk Level": "High",
            "Status": "Open",
            "Discovered": "10/12/2023",
            "Discovered By": "Unknown",
            "Resolution": "Regular security testing and assessment of EVSEs",
            "Priority": "High",
            "Tags": ["EVCS", "EVSEs", "Integrity"]
          },
          {
            "Vulnerability": "Physical Attack",
            "Risk Level": "Medium",
            "Status": "Closed",
            "Discovered": "1/12/2023",
            "Discovered By": "Unknown",
            "Resolution": "Surveillance systems, access controls, and tamper-resistant designs for the charging equipment",
            "Priority": "Medium",
            "Tags": ["EVCS", "Physical Security"]
          },
          {
            "Vulnerability": "Unauthorized Client",
            "Risk Level": "Medium",
            "Status": "Open",
            "Discovered": "14-12-2023",
            "Discovered By": "Unknown",
            "Resolution": "Secure communication protocols",
            "Priority": "Medium",
            "Tags": ["DER", "Communication"]
          },
          {
            "Vulnerability": "Invalid Packet",
            "Risk Level": "Medium",
            "Status": "Open",
            "Discovered": "11/12/2023",
            "Discovered By": "Unknown",
            "Resolution": "Secure communication protocols",
            "Priority": "Low",
            "Tags": ["DER", "Communication"]
          },
          {
            "Vulnerability": "Spoof TCP Handshake",
            "Risk Level": "Medium",
            "Status": "Open",
            "Discovered": "15-12-2023",
            "Discovered By": "Unknown",
            "Resolution": "Secure communication protocols",
            "Priority": "High",
            "Tags": ["DER", "Communication"]
          },
          {
            "Vulnerability": "Man-in-the-Middle Denial-of-Service",
            "Risk Level": "Medium",
            "Status": "Open",
            "Discovered": "12/12/2023",
            "Discovered By": "Unknown",
            "Resolution": "Robust encryption, authentication mechanisms, and secure communication protocols",
            "Priority": "Medium",
            "Tags": ["DER", "Data Transmission", "Integrity", "Confidentiality"]
          },
          {
            "Vulnerability": "Man-in-the-Middle Data Spoof",
            "Risk Level": "Low",
            "Status": "Closed",
            "Discovered": "3/12/2023",
            "Discovered By": "Unknown",
            "Resolution": "Robust encryption, authentication mechanisms, and secure communication protocols",
            "Priority": "High",
            "Tags": ["DER", "Data Transmission", "Integrity", "Confidentiality"]
          }
        ]
        );
        return;
      }

      const testResultsData = await response.json();
      setTestResults(testResultsData);
    } catch (error) {
      console.error("Error fetching test results:", error);

      setTestResults([
        {
          "Vulnerability": "False Data Injection",
          "Risk Level": "Critical",
          "Status": "Open",
          "Discovered": "2/12/2023",
          "Discovered By": "Swans Team",
          "Resolution": "Secure communication protocols, encryption, and authentication mechanisms",
          "Priority": "High",
          "Tags": ["EVCS", "Charging Data", "Integrity"]
        },
        {
          "Vulnerability": "Man-in-the-Middle",
          "Risk Level": "High",
          "Status": "Closed",
          "Discovered": "1/12/2023",
          "Discovered By": "Unknown",
          "Resolution": "Robust encryption, authentication mechanisms, and secure communication protocols",
          "Priority": "Medium",
          "Tags": ["EVCS", "Data Transmission", "Integrity", "Confidentiality"]
        },
        {
          "Vulnerability": "Denial of Service",
          "Risk Level": "High",
          "Status": "Open",
          "Discovered": "3/12/2023",
          "Discovered By": "Unknown",
          "Resolution": "Traffic filtering, rate limiting, and anomaly detection techniques",
          "Priority": "High",
          "Tags": ["EVCS", "Network Functionality", "Reliability"]
        },
        {
          "Vulnerability": "Malware Injections",
          "Risk Level": "High",
          "Status": "Open",
          "Discovered": "10/12/2023",
          "Discovered By": "Unknown",
          "Resolution": "Regular security testing and assessment of EVSEs",
          "Priority": "High",
          "Tags": ["EVCS", "EVSEs", "Integrity"]
        },
        {
          "Vulnerability": "Physical Attack",
          "Risk Level": "Medium",
          "Status": "Closed",
          "Discovered": "1/12/2023",
          "Discovered By": "Unknown",
          "Resolution": "Surveillance systems, access controls, and tamper-resistant designs for the charging equipment",
          "Priority": "Medium",
          "Tags": ["EVCS", "Physical Security"]
        },
        {
          "Vulnerability": "Unauthorized Client",
          "Risk Level": "Medium",
          "Status": "Open",
          "Discovered": "14-12-2023",
          "Discovered By": "Unknown",
          "Resolution": "Secure communication protocols",
          "Priority": "Medium",
          "Tags": ["DER", "Communication"]
        },
        {
          "Vulnerability": "Invalid Packet",
          "Risk Level": "Medium",
          "Status": "Open",
          "Discovered": "11/12/2023",
          "Discovered By": "Unknown",
          "Resolution": "Secure communication protocols",
          "Priority": "Low",
          "Tags": ["DER", "Communication"]
        },
        {
          "Vulnerability": "Spoof TCP Handshake",
          "Risk Level": "Medium",
          "Status": "Open",
          "Discovered": "15-12-2023",
          "Discovered By": "Unknown",
          "Resolution": "Secure communication protocols",
          "Priority": "High",
          "Tags": ["DER", "Communication"]
        },
        {
          "Vulnerability": "Man-in-the-Middle Denial-of-Service",
          "Risk Level": "Medium",
          "Status": "Open",
          "Discovered": "12/12/2023",
          "Discovered By": "Unknown",
          "Resolution": "Robust encryption, authentication mechanisms, and secure communication protocols",
          "Priority": "Medium",
          "Tags": ["DER", "Data Transmission", "Integrity", "Confidentiality"]
        },
        {
          "Vulnerability": "Man-in-the-Middle Data Spoof",
          "Risk Level": "Low",
          "Status": "Closed",
          "Discovered": "3/12/2023",
          "Discovered By": "Unknown",
          "Resolution": "Robust encryption, authentication mechanisms, and secure communication protocols",
          "Priority": "High",
          "Tags": ["DER", "Data Transmission", "Integrity", "Confidentiality"]
        }
      ]
      );
    }
  };


  useEffect(() => {
    async function fetchData() {
      try {
        const response = await fetch('/api/deviceInfo');

        if (!response.ok) {
          console.error("HTTP error", response.status);
          return;
        }

        const rawData = await response.json();

        if (typeof rawData.body === 'string') {
          const parsedData = JSON.parse(rawData.body);
          setHardwareData(parsedData);
        } else {
          setHardwareData(rawData);
        }
      } catch (error) {
        console.error("Error fetching data:", error);
      }
    }

    fetchData();
  }, []);

  useEffect(() => {
    if (typeof document !== 'undefined') {
      const keyframes = `@keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }`;

      // Apply the keyframes to the head of the document
      const styleSheet = document.styleSheets[0];
      styleSheet.insertRule(keyframes, styleSheet.cssRules.length);
    }
  }, []);

  useEffect(() => {
    if (hardwareData && hardwareData.data) {
      const filteredData = hardwareData.data.find(item => {
        const [derId] = Object.values(item);
        return derId[0] === deviceId;
      });

      if (filteredData) {
        const [
          der_id, der_name, der_type, manufacturer_id, manufacturer_serial_number,
          manufacture_date, manufacturer_hw_version, manufacturer_info,
          manufacturer_model_number, latest_sw_version, latest_sw_release_date,
          latest_firmware_version, latest_firmware_release_date, location, setting_id,
          der_id_set, set_max_ac_current, set_max_usable_energy_storage,
          set_minpf_overexcited_limit, set_minpf_underexcited_limit, set_max_apparent_power,
          set_max_reactive_power_tx, set_max_reactive_power_rx, set_max_active_power_tx,
          set_max_energy_storage, set_min_ac_voltage, set_max_ac_voltage,
          current_sw_version, sw_last_update_date, current_firmware_version,
          firmware_last_update_date
        ] = filteredData[Object.keys(filteredData)[0]];

        setDeviceData({
          der_name: der_name,
          der_type: der_type,
          location: location,
        });
      }
    }
  }, [hardwareData, deviceId]);




  const handleInputChange = (e) => {
    setTestFormData({
      ...testFormData,
      [e.target.name]: e.target.value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      // Set loading to true when starting the API call
      setLoading(true);
      setLoadingSpinnerVisible(true);

      // Add your API endpoint for saving the test data
      const response = await fetch('/api/saveTestData', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          derId: deviceId,
          der_name: deviceData.der_name,
          der_type: deviceData.der_type,
          location: deviceData.location,
          creationDate: testFormData.creationDate,
          testScope: testFormData.testScope,
          reason: testFormData.reason,
        }),
      });

      if (!response.ok) {
        console.error("HTTP error", response.status);
        setTimeout(() => {
          setLoading(false);
          setTestResultsAvailable(true);
          setLoadingSpinnerVisible(false);
        }, 10000);
        // Handle error, show message, etc.
        return;
      }

      // Successful API call
      console.log("Test data saved successfully!");

      // Set a timeout for 30 seconds to change loading state and display the button
      setTimeout(() => {
        setLoading(false);
        setTestResultsAvailable(true);
        setLoadingSpinnerVisible(false);
      }, 10000); // 30 seconds delay
    } catch (error) {
      console.error("Error saving test data:", error);
      // Handle error, show message, etc.
    }
  };

  return (
    <><div style={styles.container as any}>

       {/* <ScanForVulnerabilityTitle />  */}
       <div style={{ textAlign: 'center' , marginRight:'125px' }}>
      <span role="img" aria-label="Shield" style={{ fontSize: '50px', marginRight: '32px' }}>üõ°Ô∏è</span>
      <h2 style={{ fontSize: '24px', fontWeight: 'bold', margin: 0 }}>
        Scan for Vulnerability
      </h2>
    </div>{/* New component for title and image */}
      <div style={leftContainer as any}>
     
        {deviceData.der_name ? (
          <>
            <div style={styles.formLeft as any}>
              <label style={styles.labelT as any}><strong>DER Name:</strong> </label>
              <p>{deviceData.der_name}</p>
              <label style={styles.labelT as any}></label><strong>Type: </strong>
              <p>{deviceData.der_type}</p>
              <label style={styles.labelT as any}></label><strong>Location:</strong>
              <p>{deviceData.location}</p>
            </div>


            <form style={styles.form as any} onSubmit={handleSubmit}>
              <div>
                <label style={styles.label as any} htmlFor="creationDate">Test Creation Date:</label>
                <input
                  style={styles.input as any}
                  type="date"
                  id="creationDate"
                  name="creationDate"
                  value={testFormData.creationDate || ''}
                  onChange={handleInputChange} />
              </div>

              <div style={{ textAlign: 'center' }}>
                <label style={styles.label as any} htmlFor="testScope">Test Scope:</label>
                <select
                  style={styles.input as any} // Cast to 'any'
                  id="testScope"
                  name="testScope"
                  value={testFormData.testScope || ''}
                  onChange={handleInputChange}
                >
                  <option value="">Select Test Scope</option>
                  <option value="Website penetration testing">Website penetration testing</option>
                  <option value="API penetration testing">API penetration testing</option>
                  <option value="Network penetration testing">Network penetration testing</option>
                  <option value="Wireless penetration testing">Wireless penetration testing</option>
                  <option value="Authorisation penetration testing">Authorisation penetration testing</option>
                </select>
              </div>

              <div style={{ textAlign: 'center' }}>
                <label style={styles.label as any} htmlFor="reason">Reason:</label>
                <select
                  style={styles.input as any} // Cast to 'any'
                  id="reason"
                  name="reason"
                  value={testFormData.reason || ''}
                  onChange={handleInputChange}
                >
                  <option value="">Select Reason</option>
                  <option value="Security Standard Compliance">Security Standard Compliance</option>
                  <option value="Periodic test">Periodic test</option>
                  <option value="Risk Ranking">Risk Ranking</option>
                  <option value="Recent Security Incident">Recent Security Incident</option>
                  <option value="New enhancement and patchment">New enhancement and patchment</option>
                </select>
              </div>
              <div style={styles.buttonContainer as any}>
                <button type="submit" style={styles.button}>Submit </button>{loading && loadingSpinnerVisible && (
                  <div style={styles.loadingSpinner}></div>
                )} {!loading && testResultsAvailable && (
                  <button style={styles.viewResultsButton} onClick={() => handleViewResults()} disabled={viewResultsButtonDisabled}>
                    View Test Results
                  </button>
                )}
              </div>
            </form>
          </>
        ) : (
          <>
            <p>No data available for the specified device ID.</p>
            <form style={styles.form as any} onSubmit={handleSubmit}>
              <div style={{ textAlign: 'center' }}>
                <label style={styles.label as any} htmlFor="creationDate">Test Creation Date:</label>
                <input
                  style={styles.input as any}
                  type="date"
                  id="creationDate"
                  name="creationDate"
                  value={testFormData.creationDate || ''}
                  onChange={handleInputChange} />
              </div>

              <div style={{ textAlign: 'center' }}>
                <label style={styles.label as any} htmlFor="testScope">Test Scope:</label>
                <select
                  style={styles.input as any} // Cast to 'any'
                  id="testScope"
                  name="testScope"
                  value={testFormData.testScope || ''}
                  onChange={handleInputChange}
                >
                  <option value="">Select Test Scope</option>
                  <option value="Website penetration testing">Website penetration testing</option>
                  <option value="API penetration testing">API penetration testing</option>
                  <option value="Network penetration testing">Network penetration testing</option>
                  <option value="Wireless penetration testing">Wireless penetration testing</option>
                  <option value="Authorisation penetration testing">Authorisation penetration testing</option>
                </select>
              </div>

              <div style={{ textAlign: 'center' }}>
                <label style={styles.label as any} htmlFor="reason">Reason:</label>
                <select
                  style={styles.input as any} // Cast to 'any'
                  id="reason"
                  name="reason"
                  value={testFormData.reason || ''}
                  onChange={handleInputChange}
                >
                  <option value="">Select Reason</option>
                  <option value="Security Standard Compliance">Security Standard Compliance</option>
                  <option value="Periodic test">Periodic test</option>
                  <option value="Risk Ranking">Risk Ranking</option>
                  <option value="Recent Security Incident">Recent Security Incident</option>
                  <option value="New enhancement and patchment">New enhancement and patchment</option>
                </select>
              </div>
              <div style={styles.buttonContainer as any}>
                <button type="submit" style={styles.button}>Submit</button> {loading && loadingSpinnerVisible && (
                  <div style={styles.loadingSpinner}></div>
                )}{!loading && testResultsAvailable && (
                  <button style={styles.viewResultsButton} onClick={() => handleViewResults()} disabled={viewResultsButtonDisabled}>
                    View Test Results
                  </button>
                )}
              </div>

            </form>


          </>
        )}
      </div>
      <div style={styles.rightContainer as any}>
        {/* ... (form content) */}
        {testResults.length > 0 && (
          <TestResultsTable testResults={testResults} />
        )}
      </div>
    </div></>
  );
}
